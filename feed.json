{
  "version": "https://jsonfeed.org/version/1",
  "title": "ProgramingIsTheFuture",
  "home_page_url": "https://example.com/",
  "feed_url": "https://example.com/feed.json",
  "description": "Blogs about some interesting topics",
  "author": {
    "name": "ProgramingIsTheFuture,",
    "url": "https://github.com/ProgramingIsTheFuture"
  },
  "items": [
    {
      "id": "https://example.com/posts/go-compiler-part2/",
      "url": "https://example.com/posts/go-compiler-part2/",
      "title": "Go Compiler - Part 2",
      "content_html": "<p>This is a continuation from <a href=\"./go_compiler_part1.md\">last post</a>.</p>\n<p>After building the <strong>Ast</strong> what can we do next?\nWe can check the types and compile the program.</p>\n<p>This will be the expected:</p>\n<pre><code class=\"language-ocaml\">...\nlet code_typed =\n  [\n    Func\n      ( &quot;add&quot;,\n        [ (&quot;a&quot;, TInt); (&quot;b&quot;, TInt) ],\n        TInt,\n        [ Return (Op (Var &quot;a&quot;, &quot;+&quot;, Var &quot;b&quot;)) ] );\n    Func\n      ( &quot;main&quot;,\n        [],\n        TVoid,\n        [\n          Let (&quot;a&quot;, Some TInt, Const 10);\n          Let (&quot;b&quot;, Some TInt, Const 25);\n          Let (&quot;_&quot;, Some TInt, Apply (&quot;add&quot;, [ Var &quot;a&quot;; Var &quot;b&quot; ]));\n        ] );\n  ]\n... \n</code></pre>\n<p>Let's start by creating the type checker!\nFirst, let's create a new file <strong>typechecker.ml</strong> and define a function that takes our <strong>ast list</strong>\nand returns another <strong>ast list</strong> (but this time checked).</p>\n<pre><code class=\"language-ocaml\">val check : typ VMap.t -&gt; typ list VMap.t -&gt; stmt list -&gt; stmt list\n</code></pre>\n<p>First, let's use the Map data structure. It works identically to the HashTable in OCaml, but it's immutable, meaning that when we change the Map.v we need to store it again if we want to persist it. It is good to score the scope of variables. The VMap is the Map implementation we are using, uses a string as a key and stores the typ or typ list value (depending on the context).</p>\n<pre><code class=\"language-ocaml\">module VMap = Map.Make (String)\n\nlet ctx = VMap.empty\nlet fun_ctx = VMap.empty\n</code></pre>\n<p>This will create a context to store functions (<strong>fun_ctx</strong>) and another one to store the variables (<strong>ctx</strong>).</p>\n<p>Let's convert the <strong>Ast</strong> expressions to types.</p>\n<pre><code class=\"language-ocaml\">let rec typ_of_ex ctx fun_ctx : Ast.expr -&gt; Ast.typ = function\n  | Const _ -&gt; TInt\n  | Op _ -&gt; TInt\n  | Var s -&gt; VMap.find s ctx\n  | Apply (s, exprs) -&gt;\n      let t_l = VMap.find s fun_ctx in\n      let typs = List.map (typ_of_ex ctx fun_ctx) exprs in\n      let rec h t1 t2 =\n        match (t1, t2) with\n        | [], [ t2 ] -&gt; t2\n        | t1 :: tl1, t2 :: tl2 when t1 = t2 -&gt; h tl1 tl2\n        | _ -&gt;\n            failwith &quot;Not the right number of arguments or the type is invalid!&quot;\n      in\n      h typs t_l;;\n</code></pre>\n<p>This function with take any expression and convert it to a type.\nConst and Operators are easy, as we only support ints, for now at least. With variables we have to find them in the context.\nThe application is the hardest one, as we have to check the type of each expression and compare the types of each expression with the type required by the function.</p>\n<p>This is getting the types of the function and the type of the expressions (one by one).</p>\n<pre><code class=\"language-ocaml\">\t...\n\tlet t_l = VMap.find s fun_ctx in\n\tlet typs = List.map (typ_of_ex ctx fun_ctx) exprs in\n\t...\n</code></pre>\n<p>This function compare both of the types, and returns the <em>return type</em>.</p>\n<pre><code class=\"language-ocaml\">\t...\n\tlet rec h t1 t2 =\n\t\tmatch (t1, t2) with\n\t\t| [], [ t2 ] -&gt; t2\n\t\t| t1 :: tl1, t2 :: tl2 when t1 = t2 -&gt; h tl1 tl2\n\t\t| _ -&gt;\n\t\t\tfailwith &quot;Not the right number of arguments or the type is invalid!&quot;\n\t\tin\n\th typs t_l;;\n</code></pre>\n<p>We will need a function to check the types:</p>\n<pre><code class=\"language-ocaml\">let check_types (t1 : Ast.typ option) (t2 : Ast.typ) : Ast.typ =\n  match t1 with\n  | Some t1 -&gt; if t1 = t2 then t1 else failwith &quot;Types should be equal&quot;\n  | None -&gt; t2\n</code></pre>\n<p>And finally, we can implement the <strong>check</strong> function</p>\n<pre><code class=\"language-ocaml\">let rec check (ctx : typ VMap.t) (fun_ctx : typ list VMap.t) :\n    Ast.stmt list -&gt; Ast.stmt list = function\n  | [] -&gt; []\n  | (Return _ as ret) :: tl -&gt; ret :: check ctx fun_ctx tl\n...\n</code></pre>\n<p>Note: OCaml can infer the types, we could write this as:</p>\n<pre><code class=\"language-ocaml\">let rec check ctx fun_ctx = function\n\t...\n</code></pre>\n<p>First, we handle the empty case, and then the Return statement (we keep it equal).</p>\n<pre><code class=\"language-ocaml\">\t| Let (n, t_op, e) :: tl -&gt;\n\t  let t = typ_of_ex ctx fun_ctx e in\n\t  let t = check_types t_op t in\n\t  let ctx = VMap.add n t ctx in\n\t  Let (n, Some t, e) :: check ctx fun_ctx tl\n</code></pre>\n<p>In the Let case, we will grab the type from the expression and compare it to the type we wrote in the source code (if any), then we add that variable to the context, we create a new let but this time with a type, and finally we continue iterating.</p>\n<pre><code class=\"language-ocaml\">\t...\n\t| Func (n, params, t_op, stmts) :: tl -&gt;\n      let rec stmts_typ (stmts : Ast.stmt list) (acc : Ast.stmt list * typ) =\n        match stmts with\n        | [] -&gt; (fst acc, TVoid)\n        | [ (Return e as ret) ] -&gt;\n            ( (check ctx fun_ctx [ ret ] |&gt; List.hd) :: fst acc,\n              typ_of_ex ctx fun_ctx e )\n        | stmt :: tl -&gt;\n            stmts_typ tl\n              ((check ctx fun_ctx [ stmt ] |&gt; List.hd) :: fst acc, TVoid)\n      in\n      let stmts, t = stmts_typ stmts ([], TVoid) in\n      let stmts = List.rev stmts in\n      let t = check_types (Some t_op) t in\n      let rec mount_t (params : (string * Ast.typ) list) =\n        match params with [] -&gt; [ t ] | (_, t) :: tl -&gt; t :: mount_t tl\n      in\n      let ctx =\n        List.fold_left (fun c (nn, typ) -&gt; VMap.add nn typ c) ctx params\n      in\n      let t_mount = mount_t params in\n      let fun_ctx = VMap.add n t_mount fun_ctx in\n      Func (n, params, t, stmts) :: check ctx fun_ctx tl\n</code></pre>\n<p>For the <em>Func</em> case, first, we try to find the return type from the list of statements that will execute inside the function. After that, we check that type with the return type we wrote on the source code. Then, we add all params names to the variable context, then we group all types (the params type and the return type) into an array to know what to expect when calling the function.\nFinally, we return a new <em>Func</em> with the correct types.</p>\n<p>This code is expected to run without any error.</p>\n<pre><code class=\"language-ocaml\">...\nlet () =\n  let lex = Lexing.from_channel (open_in &quot;main.go&quot;) in\n  let typed_code =\n    Parser.code Lexer.token lex\n    |&gt; Typechecker.check Typechecker.ctx Typechecker.fun_ctx\n  in\n  assert (code_typed = typed_code)\n</code></pre>\n<p>Llvm Compilation... To be continued.</p>",
      "date_published": "2023-02-21T00:00:00Z"
    },
    {
      "id": "https://example.com/posts/go-compiler-part1/",
      "url": "https://example.com/posts/go-compiler-part1/",
      "title": "Go Compiler - Part 1",
      "content_html": "<h1>Tutorial about building compilers</h1>\n<p>In this tutorial we will use the OCaml programing language\nto build a simple compiler.\nThis will be a walk-through tutorial.</p>\n<p>Here we will be building a mini Go compiler.\nThe Syntax is the minimum to compile this:</p>\n<pre><code class=\"language-golang\">// Defining a function\n// with 2 params and 1 return\nfunc add(a int, b int) int {\n  return a + b\n}\n\nfunc main() {\n  // one way to define variables\n  var a int = 10 \n  // another way to define variables\n  b := 25\n\n  // calling functions\n  add(a, b)\n}\n</code></pre>\n<p>We will be using the dune\nbuild system for OCaml.\nDune help us to create, build and\nexecute large OCaml projects with ease.</p>\n<p>To create a project using dune we can run the following:</p>\n<pre><code class=\"language-bash\">dune init project gocompiler\n</code></pre>\n<p>The dune init is a command that must follow one of these:\nexecutable; library; project; or test.\nIn this case, what we want is to create a project,\nand then we give it the project's name.</p>\n<p>After running the command inside your terminal,\nyou can enter the folder and see that your project structure looks\nlike this:</p>\n<pre><code class=\"language-ocaml\">.\n├── bin\n│   ├── dune\n│   └── main.ml\n├── dune-project\n├── gocompiler.opam\n├── lib\n│   └── dune\n└── test\n    ├── dune\n    └── gocompiler.ml\n\n3 directories, 7 files\n</code></pre>\n<p>The <strong>bin</strong> folder is where we store our executable.<br>\nPersonally, I enjoy renaming the <strong>bin</strong> folder to <strong>src</strong>.</p>\n<p>The code inside the <strong>main.ml</strong> should look like this:</p>\n<pre><code class=\"language-ocaml\">let () = print_endline &quot;Hello, World!&quot;\n</code></pre>\n<p>we can execute our project by running:</p>\n<pre><code class=\"language-bash\">dune exec gocompiler\n</code></pre>\n<p>Now that we have our project created,\nlet's begin by defining an AST (Abstract Syntax Tree).</p>\n<p>In OCaml we can use contructors with data to define our AST.\nLet's create the <strong>ast.ml</strong> file and write the following.</p>\n<pre><code class=\"language-ocaml\">type typ =\n  | TInt\n  | TVoid\n\ntype expr =\n  (* Can be integers *)\n  | Const of int\n  (* Arithmetic operators: + - * / *)\n  | Op of expr * string * expr\n  (* Variables *)\n  | Var of string\n  (* Apply to the function this expr list *)\n  | Apply of string * expr list\nand stmt =\n  | Return of expr\n  (* Define variables with name, optional typ and a value *)\n  | Let of string * typ option * expr\n  (* Name | Params with name type | Return type | Statements for the body function *)\n  | Func of string * (string * typ) list * typ * stmt list\n</code></pre>\n<p>After our AST is defined, we can create\na simple example to demonstrate how to use it.\nThe following OCaml code will represent the previous Golang code.</p>\n<pre><code class=\"language-ocaml\">let code = \n  [\n    Func\n      ( &quot;add&quot;,\n        [ (&quot;a&quot;, TInt); (&quot;b&quot;, TInt) ],\n        TInt,\n        [ Return (Op (Var &quot;a&quot;, &quot;+&quot;, Var &quot;b&quot;)) ] );\n    Func\n      ( &quot;main&quot;,\n        [],\n        TVoid,\n        [\n          Let (&quot;a&quot;, Some TInt, Const 10);\n          Let (&quot;b&quot;, None, Const 25);\n          Let (&quot;_&quot;, None, Apply (&quot;add&quot;, [ Var &quot;a&quot;; Var &quot;b&quot; ]));\n        ] );\n  ];;\n</code></pre>\n<p>That is a list of statements, the first element is the <code>add</code> function\nwith all the params with their types, the return type,\nand the body is just a return with the <code>+</code> operator.\nLastly, the element is the <code>main</code> function\nwith empty params, the return type, and the statements to execute.</p>\n<p>Do we have to write this all the time?\nNo, we will write a parser and lexer.\nBoth working together, they will transform all the text\ninto tokens and then parse them into those OCaml expressions.</p>\n<p>At this stage, we need to create the tokens we want to parse and lex.</p>\n<p>We need to add the menhir module. Edit your dune-project file and add the follow.</p>\n<pre><code class=\"language-lisp\">(lang dune 3.5)\n\n(name gocompiler)\n\n(using menhir 2.1) ; new line\n\n...\n</code></pre>\n<p>Note: Just one line added</p>\n<p>Inside the <strong>dune</strong> file, let's add this:</p>\n<pre><code class=\"language-lisp\">...\n\n(ocamllex\n (modules lexer))\n\n(menhir\n (modules parser))\n</code></pre>\n<p>That code tells that the module Parser and Lexer\nare generated by ocamllex and menhir.</p>\n<p>Create a file named <strong>parser.mly</strong>.\nNote: the file name is the same as the one specified  dune file.</p>\n<pre><code class=\"language-ocaml\">%token LET FUNC\n%token RETURN\n%token &lt;string&gt; NAME\n%token &lt;int&gt; VALUE\n%token ADD EQUAL\n%token LBRACE RBRACE\n%token LPARENT RPARENT\n%token COMMA\n%token EOF\n</code></pre>\n<p>These tokens are a representation of the individual chars\nfrom the source code.\nThe <code>NAME</code> and <code>VALUE</code> tokens can store a value of string and int respectively.</p>\n<p>And now create a new file named <strong>lexer.mll</strong>.</p>\n<pre><code class=\"language-ocaml\">{\n  open Parser\n}\n\nrule token = parse\n  | ['\\n' ' ' '\\t'] { token lexbuf }\n  | '+' { ADD }\n  | '=' { EQUAL }\n  | '{' { LBRACE }\n  | '}' { RBRACE }\n  | '(' { LPARENT }\n  | ')' { RPARENT }\n  | ',' { COMMA }\n  | &quot;return&quot; { RETURN }\n  | &quot;var&quot; { LET }\n  | &quot;func&quot; { FUNC }\n  | ['0'-'9']+ as s { VALUE (int_of_string s) }\n  | ['A'-'Z' 'a'-'z']+ as name\n    { NAME name }\n  | eof { EOF }\n  | _ as c { failwith (Format.sprintf &quot;Char %c is invalid&quot; c) }\n</code></pre>\n<p>The <strong>lexer.mll</strong> file is trying to convert each char from the source code\nto the respective token (if possible).\nFirst, we open the Parser module (created previously) to get access\nto all these tokens.\nThe rule is ignoring all white spaces, end of lines, and tabs.\nIt's parsing all chars to its tokens and checks for the EOF.\nIf some char does not match any of these conditions then it's an invalid one.</p>\n<p>The brackets are a way to say &quot;can match with any one of the lists&quot;.\nExample: <code>['A'-'Z' 'a'-'z']+</code> is just\nmatching for any sequence of letters from A to Z or a to z.</p>\n<p>Back to <strong>parser.mly</strong>.</p>\n<pre><code class=\"language-ocaml\">%{\n  open Ast\n%}\n\n...\n</code></pre>\n<p>Open the AST module to get access to out AST.</p>\n<pre><code class=\"language-ocaml\">...\n\n%start code\n\n%type &lt;stmt list&gt; code\n\n%%\n\nparam:\n  | n = NAME t = NAME { n, (typ_of_str t) }\n\nparams:\n  | LPARENT RPARENT { [] }\n  | LPARENT p = separated_nonempty_list(COMMA, param) RPARENT \n    { p }\n\nop:\n  | v1 = expr ADD v2 = expr { Op (v1, &quot;+&quot;, v2) }\n\napply:\n  | n = NAME LPARENT e = separated_nonempty_list(COMMA, expr) RPARENT\n    { \n      Apply (n, e)\n    } \n\nexpr:\n  | LPARENT e = expr RPARENT { e }\n  | v = VALUE { Const v }\n  | n = NAME { Var n }\n  | o = op { o }\n  | a = apply { a }\n\nstmt:\n  | RETURN e = expr { Return e }\n  | LET n = NAME EQUAL e = expr { Let (n, None, e) }\n  | LET n = NAME t = NAME EQUAL e = expr \n    {\n      let t = typ_of_str t in\n      Let (n, Some t, e)\n    }\n  | FUNC n = NAME p = params t = NAME? LBRACE s = list(stmt) RBRACE \n    { \n      let t = match t with | Some t -&gt; typ_of_str t | None -&gt; TVoid in\n      Func (n, p, t, s) \n    }\n  | e = expr {Let (&quot;_&quot;, None, e)}\n\ncode: s = list(stmt) EOF { s } \n</code></pre>\n<p>WOW, this is a lot of code!\nThe first two lines set the entry point and the type of its return.</p>\n<p>Try and read it from bottom to top, and do it like this:\nStarting in <code>code</code>, we can read as\n&quot;list of stmt followed by EOF we just return the list of stmt&quot;.</p>\n<p>Example of how to read stmt:</p>\n<pre><code class=\"language-ocaml\">| LET n = NAME t = NAME EQUAL e = expr \n  {\n    let t = typ_of_str t in\n    Let (n, Some t, e)\n  }\n</code></pre>\n<ul>\n<li>If we have the LET token followed by a NAME with any that is being named &quot;n&quot; value followed by\ntype that is just another NAME,\nfollowed by the equal sign and then any expression of type t.</li>\n</ul>\n<p>The <code>stmt</code> match for all the stmt in our AST,\ninside <code>stmt</code>, the FUNC has some parameters,\nand the way it checks for those is by looking for a\nlist separated by a comma.\nNote: <code>stmt</code> and <code>expr</code> are recursive.</p>\n<pre><code class=\"language-ocaml\">stmt:\n  ...\n  | a = apply {Let (&quot;_&quot;, None, a)}\n</code></pre>\n<p>Is just a way to accept any expr as stmt.</p>\n<p>The <code>expr</code> is doing the same as stmt but for expr.</p>\n<p>Let's start using the modules we just created.\nInside the <strong>main.ml</strong></p>\n<pre><code class=\"language-ocaml\">open Ast \n\nlet code = \n  [\n    Func\n      ( &quot;add&quot;,\n        [ (&quot;a&quot;, TInt); (&quot;b&quot;, TInt) ],\n        TInt,\n        [ Return (Op (Var &quot;a&quot;, &quot;+&quot;, Var &quot;b&quot;)) ] );\n    Func\n      ( &quot;main&quot;,\n        [],\n        TVoid,\n        [\n          Let (&quot;a&quot;, Some TInt, Const 10);\n          Let (&quot;b&quot;, None, Const 25);\n          Let (&quot;_&quot;, None, Apply (&quot;add&quot;, [ Var &quot;a&quot;; Var &quot;b&quot; ]));\n        ] );\n  ];;\n\nlet _ =\n  let source_code = \n&quot;func add(a int, b int) int {\n  return a + b\n}\n\nfunc main() {\n  var a int = 10 \n  var b = 25\n\n  add(a, b)\n}&quot;\n  in\n  let lex = Lexing.from_string source_code in\n  assert (code = (Parser.code Lexer.token lex));;\n</code></pre>\n<p>Accordingly, the code we just wrote parses and lexes the Golang code,\nas a result, is returning the list of tokens we expected!</p>\n<p>However, we want to parse a file and not hardcoded text.\nLet's write code to parse the main.go file.</p>\n<pre><code class=\"language-ocaml\">let () = \n  let lex = Lexing.from_channel (open_in &quot;main.go&quot;) in\n  let code_from_source = Parser.code Lexer.token lex in\n  assert (code = code_from_source)\n</code></pre>\n<p>The <strong>open_in</strong> is a OCaml function to open a file with the given name (string).\nThen we use the <strong>Parser.code</strong> to parser the text comming from the <strong>in_channel</strong>.</p>\n<p>Suggestion: Build a CLI that receives the file name or just defaults it.\nJust like the <strong>go</strong> cli works.</p>",
      "date_published": "2022-12-09T00:00:00Z"
    }
  ]
}